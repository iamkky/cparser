#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

#include "Symbol.h"
#include "Tree.h"

#include "c_parser.h"
#include "c_parser.tokens.h"
#include "c_lex.h"

#define TOKENDEBUG 1

struct keyword {
	char	*name;
	int	token;
};

struct keyword keywords[] = {
	{"auto",	AUTO},
	{"double",	DOUBLE},
	{"int",		INT},
	{"struct",	STRUCT},
	{"break",	BREAK},
	{"else",	ELSE},
	{"long",	LONG},
	{"switch",	SWITCH},
	{"case",	CASE},
	{"enum",	ENUM},
	{"register",	REGISTER},
	{"typedef",	TYPEDEF},
	{"char",	CHAR},
	{"extern",	EXTERN},
	{"return",	RETURN},
	{"union",	UNION},
	{"const",	CONST},
	{"float",	FLOAT},
	{"short",	SHORT},
	{"unsigned",	UNSIGNED},
	{"continue",	CONTINUE},
	{"for",		FOR},
	{"signed",	SIGNED},
	{"void",	VOID},
	{"default",	DEFAULT},
	{"goto",	GOTO},
	{"sizeof",	SIZEOF},
	{"volatile",	VOLATILE},
	{"do",		DO},
	{"if",		IF},
	{"static",	STATIC},
	{"while",	WHILE},
	{"asm",		ASM},		// GNU asm()
	{"__asm",	ASM},		// GNU asm()
	{"__asm__",	ASM},		// GNU asm()
	{"inline",	INLINE},	// C99 inline
	{"__inline",	INLINE},	// GNU inline
	{"__inline__",	INLINE},	// GNU inline
	{"restrict",	RESTRICT},	// C99 restrict
	{"__restrict",	RESTRICT},	// GNU restrict
	{"__restrict__",RESTRICT},	// GNU restrict
	{NULL,		0}
};


// Lex Helper function
static char *nrDupToken(char *input, int size);

char static *getString(char *input, int *cursor, char escape, char closure)
{
char *tmp, *newtmp, *p, last;
int  size, used, count;

	if((p = tmp = malloc(size = 128))==NULL) return NULL;
	*p = used = count = 0;

	if(*input++!=closure) return tmp;

	while((last = (*p++ = *input++))){
		count++;
		if(last==closure){
			*(p-1)=0;
			break;
		}else if(last==escape && *input==closure) {
			*(p-1)=closure;
			input++;
			count++;
		}
		if(++used>=size-1) {
			if((newtmp = realloc(tmp, size = (2 * size)))==NULL) {
				free(tmp);
				return NULL;
			}
			p = (tmp = newtmp) + count;
		}
	}

	(*cursor)+=count;
	return tmp;
}

int static isDigit(int ch)
{
	return ch>='0' && ch<='9';
}

int static processLineMarker(xParserType *value, char *input, int *cursor, void *extra)
{
xParserExtraDataType	*e;
char			*p, *file, *f;
int			number = 0, c = 0;

	p = input;
	input += 2;	// skip "# " 

	while(*input==' ' || *input=='\t') input++;
	while(isDigit(*input))
		number = 10 * number + (*input++) - '0';

	while(*input==' ' || *input=='\t') input++;
	if(*input=='"'){
		f = ++input;
		while(*input!=0 && *input!='"' && *input!='\n') { c++; input++; }
		file = nrDupToken(f, c);
	}

	while(*input!=0 && *input!='\n') input++;
	(*cursor)+=(input - p);

	fprintf(stderr,"#LINE %d %s\n", number, file);

	e = (xParserExtraDataType *)extra;

	e->lnumber = number;
	e->file = file;

	return 0;
}

int static processHashLines(xParserType *value, char *input, int *cursor, void *extra)
{
char	*str, *tmp;
int	count;
int	lineno;

	count=0;
	str=input;	

	if(*(input+1)==' ' && isDigit(*(input+2))){
		return processLineMarker(value, input, cursor, extra);
	}

	while(*str!=0 && *str!='\n'){
		str++;
		count++;
	}
/*
	if(((xParserExtraDataType *)extra)->struct_or_union_name_escope == 0){
		if(isTypedef = symbolTableGetType(((xParserExtraDataType *)extra)->syms, str)){
			//fprintf(stderr,"Typedef detected: %s\n", str);
			return TYPEDEF_NAME;
		}
	}
*/
	tmp = value->str = nrDupToken(input, count);
	fprintf(stderr,"#LINE:%s\n", tmp);
	free(tmp);
	
	(*cursor)+=count;
	return 0;
}

int static processIdentifier(xParserType *value, char *input, int size, void *extra)
{
struct keyword *k;
char	*str;
int	isTypedef;

	str = value->str = nrDupToken(input,size);

	for(k = keywords; k->name; k++){
		if(strcmp(str, k->name)==0){
			return k->token;
		}
	}
	
	if(((xParserExtraDataType *)extra)->struct_or_union_name_escope == 0){
		if(isTypedef = symbolTableGetType(((xParserExtraDataType *)extra)->syms, str)){
			fprintf(stderr,"Typedef detected: %s\n", str);
			return TYPEDEF_NAME;
		}
	}

	fprintf(stderr,"Identifier detected: %s\n", str);
	return IDENTIFIER;
}

int static savemarker(xParserType *value, void *extra)
{
xParserExtraDataType	*e = (xParserExtraDataType *)extra;

	value->file = e->file;
	value->lnumber = e->lnumber;
}

// Old approch for keyword, mistaken "inta;" by "int a;"
//auto			: value->str = nrDupToken(input,size); return AUTO;
//double		: value->str = nrDupToken(input,size); return DOUBLE;
//int			: value->str = nrDupToken(input,size); return INT;
//struct		: value->str = nrDupToken(input,size); return STRUCT;
//...

%%x_lex xParserType

%define i	A-Za-z_
%define I	0-9A-Za-z_

%define D	0-9
%define N	1-9
%define O	0-7
%define H	0-9A-Fa-f
%define	S	+\-
%define E	eE
%define F	flFL
%define L	uUlL

\D\D*\.\D*\E\S\D\D*\F	: value->str = nrDupToken(input,size); savemarker(value, extra); return FLOAT_CONST;
\D\D*\.\D*\E\S\D\D*	: value->str = nrDupToken(input,size); savemarker(value, extra); return FLOAT_CONST;
\.\D*\E\S\D\D*\F	: value->str = nrDupToken(input,size); savemarker(value, extra); return FLOAT_CONST;
\.\D*\E\S\D\D*		: value->str = nrDupToken(input,size); savemarker(value, extra); return FLOAT_CONST;
\D\D*\.\D\F		: value->str = nrDupToken(input,size); savemarker(value, extra); return FLOAT_CONST;
\D\D*\.\D		: value->str = nrDupToken(input,size); savemarker(value, extra); return FLOAT_CONST;
\.\D\D*\F		: value->str = nrDupToken(input,size); savemarker(value, extra); return FLOAT_CONST;
\.\D\D*			: value->str = nrDupToken(input,size); savemarker(value, extra); return FLOAT_CONST;
\.\D\D*\F		: value->str = nrDupToken(input,size); savemarker(value, extra); return FLOAT_CONST;

\D\D*f			: value->str = nrDupToken(input,size); savemarker(value, extra); return FLOAT_CONST;
\D\D*F			: value->str = nrDupToken(input,size); savemarker(value, extra); return FLOAT_CONST;

0x\H\H*\L		: value->str = nrDupToken(input,size); savemarker(value, extra); return INTEGER_CONST;
0x\H\H*			: value->str = nrDupToken(input,size); savemarker(value, extra); return INTEGER_CONST;
0X\H\H*\L		: value->str = nrDupToken(input,size); savemarker(value, extra); return INTEGER_CONST;
0X\H\H*			: value->str = nrDupToken(input,size); savemarker(value, extra); return INTEGER_CONST;
0\O\O*\L		: value->str = nrDupToken(input,size); savemarker(value, extra); return INTEGER_CONST;
0\O\O*			: value->str = nrDupToken(input,size); savemarker(value, extra); return INTEGER_CONST;
\N\D*\L			: value->str = nrDupToken(input,size); savemarker(value, extra); return INTEGER_CONST;
\N\D*			: value->str = nrDupToken(input,size); savemarker(value, extra); return INTEGER_CONST;
0			: value->str = nrDupToken(input,size); savemarker(value, extra); return INTEGER_CONST;


'			: value->str = getString(input, cursor, '\\', '\''); savemarker(value, extra); return CHARACTER_CONST;
L'			: value->str = getString(input, cursor, '\\', '\''); savemarker(value, extra); return CHARACTER_CONST;

"			: value->str = getString(input, cursor, '\\', '\"'); savemarker(value, extra); return STRING;
L"			: value->str = getString(input, cursor, '\\', '\"'); savemarker(value, extra); return STRING;

\i\I*			: savemarker(value, extra); return processIdentifier(value, input, size, extra);

[			: value->str = nrDupToken(input,size); savemarker(value, extra); return OB;
]			: value->str = nrDupToken(input,size); savemarker(value, extra); return CB;
(			: value->str = nrDupToken(input,size); savemarker(value, extra); return OP;
)			: value->str = nrDupToken(input,size); savemarker(value, extra); return CP;
*=			: value->str = nrDupToken(input,size); savemarker(value, extra); return ASSIGN_MUL;
/=			: value->str = nrDupToken(input,size); savemarker(value, extra); return ASSIGN_DIV;
%=			: value->str = nrDupToken(input,size); savemarker(value, extra); return ASSIGN_MOD;
+=			: value->str = nrDupToken(input,size); savemarker(value, extra); return ASSIGN_ADD;
-=			: value->str = nrDupToken(input,size); savemarker(value, extra); return ASSIGN_SUB;
<<=			: value->str = nrDupToken(input,size); savemarker(value, extra); return ASSIGN_SHFL;
>>=			: value->str = nrDupToken(input,size); savemarker(value, extra); return ASSIGN_SHFR;
&=			: value->str = nrDupToken(input,size); savemarker(value, extra); return ASSIGN_AND;
^=			: value->str = nrDupToken(input,size); savemarker(value, extra); return ASSIGN_NEG;
|=			: value->str = nrDupToken(input,size); savemarker(value, extra); return ASSIGN_OR;

<<			: value->str = nrDupToken(input,size); savemarker(value, extra); return SHIFTLEFT;
>>			: value->str = nrDupToken(input,size); savemarker(value, extra); return SHIFTRIGHT;
<=			: value->str = nrDupToken(input,size); savemarker(value, extra); return CMP_LE;
>=			: value->str = nrDupToken(input,size); savemarker(value, extra); return CMP_GE;
==			: value->str = nrDupToken(input,size); savemarker(value, extra); return CMP_EQ;
!=			: value->str = nrDupToken(input,size); savemarker(value, extra); return CMP_NE;
<			: value->str = nrDupToken(input,size); savemarker(value, extra); return CMP_LT;
>			: value->str = nrDupToken(input,size); savemarker(value, extra); return CMP_GT;

->			: value->str = nrDupToken(input,size); savemarker(value, extra); return ARROW;
++			: value->str = nrDupToken(input,size); savemarker(value, extra); return INC;
--			: value->str = nrDupToken(input,size); savemarker(value, extra); return DEC;
&&			: value->str = nrDupToken(input,size); savemarker(value, extra); return LOG_AND;
||			: value->str = nrDupToken(input,size); savemarker(value, extra); return LOG_OR;
*			: value->str = nrDupToken(input,size); savemarker(value, extra); return STAR;
+			: value->str = nrDupToken(input,size); savemarker(value, extra); return PLUS;
-			: value->str = nrDupToken(input,size); savemarker(value, extra); return MINUS;
~			: value->str = nrDupToken(input,size); savemarker(value, extra); return NEG;
!			: value->str = nrDupToken(input,size); savemarker(value, extra); return LOG_NOT;
/			: value->str = nrDupToken(input,size); savemarker(value, extra); return DIV;
%			: value->str = nrDupToken(input,size); savemarker(value, extra); return MODULE;
^			: value->str = nrDupToken(input,size); savemarker(value, extra); return BIT_EOR;
&			: value->str = nrDupToken(input,size); savemarker(value, extra); return AMPERSAND;
|			: value->str = nrDupToken(input,size); savemarker(value, extra); return BIT_OR;
?			: value->str = nrDupToken(input,size); savemarker(value, extra); return TERNARY;
\:			: value->str = nrDupToken(input,size); savemarker(value, extra); return COLON;
=			: value->str = nrDupToken(input,size); savemarker(value, extra); return ASSIGN;
,			: value->str = nrDupToken(input,size); savemarker(value, extra); return COMMA;

{			: value->str = nrDupToken(input,size); savemarker(value, extra); return OBLOCK;
}			: value->str = nrDupToken(input,size); savemarker(value, extra); return CBLOCK;
;			: value->str = nrDupToken(input,size); savemarker(value, extra); return SEMICOLON;
\.\.\.			: value->str = nrDupToken(input,size); savemarker(value, extra); return ELLIPSIS;
\.			: value->str = nrDupToken(input,size); savemarker(value, extra); return DOT;

\s			: 
\n			: 
\t			: 
\r			: 

#			: processHashLines(value, input, cursor, extra);

