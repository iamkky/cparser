#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdio.h>
#include <stdarg.h>

#include "Tree.h"
#include "Symbol.h"

#include "c_parser.h"
#include "c_parser.tokens.h"
#include "c_lex.h"

#define DDEBUG 1
#define TOKENDEBUG 1
#define RETURNDEBUG 1

struct cparser_extra{
        SymbolTable     syms;
};

#define _ddebug_printf _ddprintf

static int _ddprintf(char *fmt, ...)
{
va_list ap;
int	r;

	va_start(ap, fmt);
	r = vfprintf(stderr, fmt, ap);
	va_end(ap);
	return r;
}
 

void static safe_free(void *ptr)
{
	if(ptr) free(ptr);
}

int default_action(xParser self, xParserType *result, xParserType *terms, int *types, int start, int end, int nt_id)
{
Tree t;
int  i;

	if(result->t==NULL)
		t = treeNew(nt_id, "nt");
	else
		t = result->t;

	if((result->t == NULL) || (result->t != NULL && start>0)){
		for(i=start; i<end; i++){
			if(types[i] < RDPP_NONTERMINAL_START){
				treeAddChild(t, treeNew(types[i], terms[i].str));
			}else{
				treeAddChild(t, terms[i].t);
			}
		}
	}

	result->t = t;
}

static int typedefFlag = 0;


%%xParser top x_lex
union {
	Tree	t;
	char	*str;
}
%%

%%action { default_action(self, &result, terms, types, start, end, rdpp_nt_id); }

%%names

#top: lextest ;
top: translation_unit ;

# 3.1.3 Constants
constant:
	FLOAT_CONST
	| INTEGER_CONST
	| CHARACTER_CONST
	| ENUMERATION_CONST
	;

# 3.1.3.3 Enumeration constants

enumeration_constant:
	IDENTIFIER
	;

# 3.3.1 Primary expressions
primary_expression:
	IDENTIFIER
	| constant
	| STRING
	| OP  expression CP
	;

# 3.3.2 Postfix operators
postfix_expression:
	primary_expression postfix_expression_lr
	;

postfix_expression_lr:
	OB  expression CB postfix_expression_lr
	| OP  argument_expression_list_opt CP postfix_expression_lr
	| DOT   IDENTIFIER postfix_expression_lr
	| ARROW  IDENTIFIER postfix_expression_lr
	| DEC postfix_expression_lr
	| INC postfix_expression_lr
	|
	;

argument_expression_list_opt:
	argument_expression_list
	|
	;

argument_expression_list:
	assignment_expression [ COMMA assignment_expression ]
	;

# 3.3.3 Unary operators
unary_expression:
	postfix_expression
	| INC unary_expression
	| DEV unary_expression
	| unary_operator cast_expression
	| SIZEOF  unary_expression
	| SIZEOF OP type_name CP
	;

unary_operator:
	AMPERSAND
	| START
	| PLUS
	| MINUS
	| NEG
	| LOG_NOT
	;

# 3.3.4 Cast operators
cast_expression:
	unary_expression
	| OP type_name CP cast_expression
	;

# 3.3.5 Multiplicative operators
multiplicative_expression:
	cast_expression [ multiplicative_expression_operator cast_expression ]
	;

multiplicative_expression_operator:
	STAR
	| DIV
	| MODULE
	;

# 3.3.6 Additive operators
additive_expression:
	multiplicative_expression [ additive_expression_operator  multiplicative_expression ]
	;

additive_expression_operator:
	PLUS
	| MINUS
	;

# 3.3.7 Bitwise shift operators
shift_expression:
	additive_expression [ shift_expression_operator additive_expression ]
	;

shift_expression_operator:
	SHIFTLEFT
	| SHIFTRIGHT
	;

# 3.3.8 Relational operators
relational_expression:
	shift_expression [ relational_expression_operator shift_expression ]
	;

relational_expression_operator:
	CMP_LT
	| CMP_GT
	| CMP_LE
	| CMP_GE
	;

# 3.3.9 Equality operators
equality_expression:
	relational_expression [ equality_expression_operator relational_expression ]
	;

equality_expression_operator:
	CMP_EQ
	| CMP_NE
	;

# 3.3.10 Bitwise and operator
and_expression:
	equality_expression [ AMPERSAND equality_expression ]
	;

# 3.3.11 Bitwise exclusive or operator
exclusive_or_expression:
	and_expression [ BIT_EOR and_expression ]
	;

# 3.3.12 Bitwise inclusive or operator
inclusive_or_expression:
	exclusive_or_expression [ BIT_OR exclusive_or_expression ]
	;

# 3.3.13 Logical and operator
logical_and_expression:
	inclusive_or_expression [ LOG_AND inclusive_or_expression ]
	;

# 3.3.14 Logical or operator
logical_or_expression:
	logical_and_expression [ LOG_OR logical_and_expression ]
	;

# 3.3.15 Conditional operator
conditional_expression:
	logical_or_expression conditional_expression_disambiguation
	;

conditional_expression_disambiguation:
	TERNARY expression COLON conditional_expression
	|
	;

# 3.3.16 Assignment operators

# assignment_expression:
#	unary_expression assignment_operator assignment_expression
#	| conditional_expression
#	;
#
#	assignment-operator: one of   (for later)
#	=  *=  /=  %=  +=  -=  <<=  >>=  &=  ^=  |=   (for later)
#
#	condition_expression can reduce to an unary_expression
#	this ruleset has to rules that start with same TERMINAL.
#	A solution is to change unary_expression to condition_expression 
#	and use a disambiguation technic, and let correctness check for
#	semantic.
#
#	So the ruleset changes to:
#	conditional_expression assignment_operator assignment_expression
#	| conditional_expression
#	;

assignment_expression:
	conditional_expression [ assignment_operator conditional_expression ]
	;

assignment_expression_disambiguation:
	assignment_operator assignment_expression
	|
	;

assignment_operator:
	ASSIGN | ASSIGN_MUL | ASSIGN_DIV | ASSIGN_MOD | ASSIGN_ADD | ASSIGN_SUB
	| ASSIGN_SHFL | ASSIGN_SHFR | ASSIGN_AND | ASSIGN_NEG | ASSIGN_OR
	;

# 3.3.17 Comma operator

#expression:
#	assignment_expression
#	| expression COMMA assignment_expression
#	;
# Under construction
	
expression_opt:
	expression
	|
	;

expression:
	assignment_expression [ COMMA assignment_expression ]
	;

#3.4 CONSTANT EXPRESSIONS *****

constant_expression_opt:
	constant_expression
	|
	;

constant_expression:
	conditional_expression
	;

# 3.5 DECLARATIONS

#declaration:
#	declaration_specifiers init_declarator_list_opt SEMICOLON
#	;

declaration:
	{ typedefFlag = 0; }
	declaration_specifiers init_declarator_list_opt function_definition_or_declaration_end
	;

function_definition_or_declaration_end:
	compound_statement
	| SEMICOLON
	|
	;

declaration_specifiers:
	storage_class_specifier declaration_specifiers_opt
	| type_specifier declaration_specifiers_opt
	| type_qualifier declaration_specifiers_opt
	;

declaration_specifiers_opt:
	declaration_specifiers
	|
	;

init_declarator_list_opt:
	init_declarator_list
	|
	;
##
## init_declarator_list:
##	init_declarator
##	| init_declarator_list COMMA init_declarator
##	;

init_declarator_list:
	init_declarator [ COMMA init_declarator ]
	;

init_declarator:
	declarator 
	#| declarator ASSIGN initializer (for later)
	;


#3.5.1 Storage-class specifiers
storage_class_specifier:
	TYPEDEF { typedefFlag = 1; }
	| EXTERN
	| STATIC
	| AUTO
	| REGISTER
	;

#3.5.2 Type specifiers
type_specifier:
	VOID
	| CHAR
	| SHORT
	| INT
	| LONG
	| FLOAT
	| DOUBLE
	| SIGNED
	| UNSIGNED
	| struct_or_union_specifier
	| enum_specifier
	| TYPEDEF_NAME
	;

# 3.5.2.1 Structure and union specifiers

##struct_or_union_specifier:
##	struct_or_union identifier<opt> { struct_declaration_list } 
##	| struct_or_union identifier
##	;

struct_or_union_specifier:
	struct_or_union struct_or_union_specifier_disambiguation
	;

struct_or_union_specifier_disambiguation:
	OBLOCK struct_declaration_list CBLOCK
	| IDENTIFIER struct_or_union_specifier_disambiguation2 
	;

struct_or_union_specifier_disambiguation2:
	OBLOCK struct_declaration_list CBLOCK
	|
	;

struct_or_union:
	STRUCT
	| UNION
	;

##struct_declaration_list:
##	struct_declaration
##	| struct_declaration_list struct_declaration
##	;

struct_declaration_list:
	struct_declaration [ struct_declaration ]
	;

struct_declaration:
	specifier_qualifier_list struct_declarator_list SEMICOLON
	;

specifier_qualifier_list_opt:
	specifier_qualifier_list
	|
	;

specifier_qualifier_list:
	type_specifier specifier_qualifier_list_opt
	| type_qualifier specifier_qualifier_list_opt
	;

##struct_declarator_list:
##	struct_declarator
##	| struct_declarator_list COMMA  struct_declarator
##	;

struct_declarator_list:
	struct_declarator [ COMMA struct_declarator ]
	;

##struct_declarator:
##	declarator
##	| declarator<opt> :  constant_expression
##	;

struct_declarator:
	declarator struct_declarator_disambiguation
	| COLON constant_expression
	;

struct_declarator_disambiguation:
	COLON  constant_expression
	|
	;

# 3.5.2.2 Enumeration specifiers

#enum_specifier:
#	ENUM identifier<opt> OBLOCK enumerator_list CBLOCK
#	| ENUM identifier
#	;

enum_specifier:
	ENUM enum_specifier_disambiguation
	;

enum_specifier_disambiguation:
	OBLOCK enumerator_list CBLOCK
	| IDENTIFIER  enum_specifier_disambiguation2
	;

enum_specifier_disambiguation2:
	OBLOCK enumerator_list CBLOCK
	|
	;

#enumerator_list:
#	enumerator
#	| enumerator_list COMMA enumerator
#	;

enumerator_list:
	enumerator [ COMMA enumerator ]
	;

#enumerator:
#	enumeration_constant
#	| enumeration_constant ASSIGN constant_expression
#	;

enumerator:
	enumeration_constant enumerator_disambiguation
	;

enumerator_disambiguation:
	ASSIGN constant_expression
	|
	;


# 3.5.3 Type qualifiers
#
type_qualifier:
	CONST
	| VOLATILE
	;
				  

#3.5.4 Declarators
declarator:
	pointer_opt direct_declarator
	;

##direct_declarator:
##	identifier
##	| OP declarator CP 
##	| direct_declarator OB constant_expression_opt CB 
##	| direct_declarator OP parameter_type_list CP 
##	| direct_declarator OP identifier_list_opt CP
##	;

direct_declarator:
	IDENTIFIER direct_declarator_lr { 
			fprintf(stderr,"IDENT: %s, %d\n", terms[0].str, typedefFlag);
			if(typedefFlag){
				symbolTableRegister(((struct cparser_extra *)(self->extra))->syms, terms[0].str, 1);
			}
		}
	| OP declarator CP direct_declarator_lr
	;

direct_declarator_lr:
	OB constant_expression_opt CB direct_declarator_lr

	# changed to parameter_type_list_opt because it must accept and empty list
	#| OP parameter_type_list CP direct_declarator_lr
	| OP parameter_type_list_opt CP direct_declarator_lr

	# I Suppose next production is for K&R style - will not support by now
	# to avoid the need for disambiguation
	#| OP identifier_list_opt CP direct_declarator_lr (for later)
	|
	;

pointer_opt:	
	pointer
	|
	;

##pointer:
##	STAR type_qualifier_list_opt
##	| STAR type_qualifier_list_opt pointer
##	;

pointer:
	STAR type_qualifier_list_opt pointer_opt
	;

type_qualifier_list_opt:
	type_qualifier_list
	|
	;

##type_qualifier_list:
##	type_qualifier
##	| type_qualifier_list type_qualifier
##	;

type_qualifier_list:
	type_qualifier [ type_qualifier ]
	;

parameter_type_list_opt:
	parameter_type_list
	|
	;

parameter_type_list:
	parameter_list 
	#parameter_type_list_disambiguation
	;

# Will not accept ELLIPSIS here
parameter_type_list_disambiguation:
	COMMA ELLIPSIS
	|
	;

##parameter_list:
##	parameter_declaration
##	| parameter_list COMMA parameter_declaration
##	;

parameter_list:
	parameter_declaration [ COMMA parameter_declaration ]
	;

parameter_declaration:
	declaration_specifiers parameter_declaration_disambiguation
	# Accepting ELLIPSIS here by now
	| ELLIPSIS
	;

parameter_declaration_disambiguation:
	declarator
	| abstract_declarator_opt
	;

#
#
# identifier_list:
#	identifier 
#	| identifier_list COMMA  identifier
#	;

## I Suppose it's for K&R support. Will not support by now
##
##identifier_list:
##	IDENTIFIER identifier_list_lr
##	;
##
##dentifier_list_opt:
##	identifier_list
##	|
##	;
##
##identifier_list_lr:
##	COMMA  IDENTIFIER
##	|
##	;
##

#3.5.5 Type names

type_name:
	specifier_qualifier_list abstract_declarator_opt
	;

abstract_declarator_opt:
	abstract_declarator
	|
	;

abstract_declarator:
	pointer
	pointer_opt direct_abstract_declarator
	;

direct_abstract_declarator_opt:
	direct_abstract_declarator
	|
	;

direct_abstract_declarator:
	OP  abstract_declarator CP 
	| direct_abstract_declarator_opt OB  constant_expression_opt CB 
	| direct_abstract_declarator_opt OP  parameter_type_list_opt CP
	;

# 3.6 STATEMENTS

statement:
	labeled_statement
	| compound_statement
	| expression_statement
	| selection_statement
	| iteration_statement
	| jump_statement
	;

# 3.6.1 Labeled statements

labeled_statement:
	# rule starting with IDENTIFIER conflicts with statement.
	# parser needs to look ahead second token to disambiguate
	# bit rdppgen does not perform look ahead
	# A diffetente solution need to be done
	# 
	#IDENTIFIER COLON  statement
	#| CASE  constant_expression COLON  statement
	CASE constant_expression COLON statement
	| DEFAULT COLON statement
	;


# 3.6.2 Compound statement, or block

# As both declaration_list<opt> statement_list<opt> are only used here
# We can safely remove <opt> flags and at empty for ruleset os both 
# these nonterminals
#
#compound_statement:
#	OBLOCK declaration_list<opt> statement_list<opt> CBLOCK
#	;
#
#declaration_list:
#	declaration
#	| declaration-list declaration
#	;
#
#statement_list:
#	statement
#	| statement-list statement
#	;

compound_statement:
	OBLOCK declaration_list statement_list CBLOCK
	;

declaration_list:
	declaration [ declaration ]
	|
	;

statement_list:
	statement [ statement ]
	|
	;

#statement_list:
#	statement statement_list
#	|
#	;

# 3.6.3 Expression and null statements

#expression_statement:
#	expression_opt SEMICOLON
#	;

expression_statement:
	expression SEMICOLON
	| SEMICOLON
	;

# 3.6.4 Selection statements

#selection_statement:
#	IF OP expression CP  statement
#	| IF OP expression CP  statement ELSE  statement
#	| SWITCH OP  expression CP  statement
#	;

selection_statement:
	IF OP expression CP statement selection_statement_disambiguation
	| SWITCH OP expression CP statement
	;

selection_statement_disambiguation:
	ELSE statement
	|
	;

# 3.6.5 Iteration statements

iteration_statement:
	WHILE OP  expression CP  statement
	| DO  statement WHILE OP  expression CP SEMICOLON
	| FOR OP expression_opt SEMICOLON expression_opt SEMICOLON expression_opt CP statement
	;

# 3.6.6 Jump statements

jump_statement:
	GOTO IDENTIFIER SEMICOLON
	| CONTINUE SEMICOLON
	| BREAK SEMICOLON
	| RETURN return_value SEMICOLON
	;

# Added for disambiguation
# 
return_value:
	expression
	| 
	;

# 3.7 EXTERNAL DEFINITIONS

##translation_unit:
##	external_declaration
##	| translation_unit external_declaration
##	;

translation_unit:
	external_declaration translation_unit
	|
	;

# Gonna check semantics of function definitions after parser
# To simplify the parser will accept any sequence of declarartions
# or compound_statement.
# A compound_statement that follows a functions declaration will
# be accepted as a function definition
# Otherwise a compound-statement no following a functions declaration
# will be rejected as an error.
#
#external_declaration:
#	function_definition   (for later)
#	| declaration
#	;

external_declaration:
	declaration
	;

# 3.7.1 Function definitions

#function-definition:
#	declaration-specifiers<opt> declarator
#	declaration-list<opt> compound-statement

